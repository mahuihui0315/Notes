# MySQL进阶

## 基础架构：一条SQL查询语句的执行流程

### 连接器

+ 连接器负责跟客户端建立连接、获取权限、维持和管理连接

#### 长连接

+ 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接
+ 消耗内存较多，占用的资源直到关闭连接才会释放
+ 解决方法：
   + 关闭连接并重新建立
   + 使用mysql_reset_connection，初始化连接
#### 短链接
+ 每次执行完很少的查询就断开连接，下次查询重新建立连接

### 查询缓存

+ 每次进行查询之后结果会保存到查询缓存中，下次查询若在缓存中存在就直接返回
+ 每次更新会重新加载缓存，实际效率比较低
+ MySQL8.0以后删除了该功能

### 分析器

+ 检查输入语法格式是否正确
+ 以及查询条件是否有误，例如查询不存在的列

### 优化器

+ 对将要执行的语句选择合适的执行方式

### 执行器

+ 判断是否有对该表的操作权限
+ 若有权限，开始查询
   1. 调用 InnoDB 引擎接口取这个表的第一行，判断是否满足查询条件，满足则存入结果集
   ，不是则跳过
   2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行
   3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端

## 日志系统：一条SQL更新语句的执行流程
+ 更新流程涉及两个重要的日志模块
   1. redo log
   2. binlog
   
### redo log
+ InnoDB数据库持有
+ 当有一条记录需要更新时，InnoDB会先把记录写到redo log中，等到操作不忙时，在写进磁盘中。
+ InnoDB 的 redo log 是固定大小的，从头开始写，写到末尾就又回到开头循环写，当write point
赶上check point时表明redo log用完，需要清除一些记录   
+ 因为redo log的存在，即使数据库发生重启，之前的数据也不会丢失

### binlog
+ binlog为MySQL的server层实现的，所有引擎都可以使用
+ redo log为物理日志，记录了修改内容，而binlog为逻辑日记，记录了修改的原始逻辑
+ binlog为追加写入，文件达到一定大小时，切换下一个

### update的执行流程
1. 根据条件查询记录
2. 数据不在内存中则从磁盘读取，在就返回数据
3. 执行update内容
4. 写入更新到内存中
5. 写入redolog，处于prepare状态
6. 写binlog
7. 提交事务，redolog处于commit状态

### 事务的使用
+ 使用事务进行两阶段提交，是为了使两份数据的状态保持一致
+ 若数据不一致则会在，导出binlog进行数据恢复时出现状态不一致导致数据丢失

## 事务隔离

### 事务特性
+ 原子性：Automicity
+ 一致性：Consistency
+ 隔离性：Isolation
+ 持久性：Durability

### 隔离级别
+ 读未提交：read uncommiteed
+ 读已提交：read committed
+ 可重复读：repeatable read
+ 串行化：serializable

### 回滚操作
+ 假设一个值从1开始，按顺序改为了2,3,4，则在回滚日志中会有不同的read-view和不同时间
查询该值的事务所对应，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制
+ 当系统中没有比回滚日志更早的read-view时，回滚日志就会被删除

### 事务的启动方式
+ 显示启动
   1. start transaction
   2. commit
   3. rollback
+ set autocommit=0
> 关闭自动提交从执行语句，开始事务，直到commit或rollback，或断开连接

因为长事务会占用大量资源及存储空间，因此尽量使用自动提交，并显示的开启事务；
若重复开启提交事务操作繁琐可使用commit work and chain，提并开启新事物

## 索引
+ 索引的出现是为了提高查询速度
### 常见索引模型

#### hash表
讲值存进value中，并通过hash函数将key换算成一个确定的位置；当出现key重复时，会在重复
位置维护一个链表

+ 优点：追加新纪录很快，只需往后追加即可
+ 缺点：因为索引不是有序的，区间查询会十分缓慢

因此hash表只适用于等值查询的场景

#### 有序数组
+ 优点：有序数组在等值查询和区间查询都很优秀
+ 缺点：若在中间插入一条数据，需要将之后的数据全部移动

因此有序数组只适用于，静态存储引擎，数据一旦生成基本不要改动的场景

#### 二叉搜索树
二叉树的查询时间，以为用于维护平衡二叉树的时间都是 o(logN)，所以在查询和修改
都有不错的效率。但是一旦数据过多，导致二叉树树高过大，也会增大运行时间，因此
更多使用的是多叉树

### InnoDB的索引模型
InnoDB中表是根据主键顺序以索引的形式存放的
+ 主键索引：叶子结点存放的整行数据
+ 非主键索引：叶子结点存放的是主键的值

因此主键索引查询会直接得到对应数据，而非主键索引查询会得到主键，通过主键索引
再查询一次，所以应该尽量使用主键索引查询

### 索引维护
自增主键会自动获取当前主键的最大值并加1，所以主键有序且不涉及挪动其他记录，
同时主键长度为4字节，减少了非主键的叶子结点的存储空间。因此从性能和存储空间看
自增主键都是更合理的选择

但是也存在适合用业务字段用于主键的场景，即典型的key-value场景
1. 只有一个索引
2. 索引必须唯一

### 回表
非主键索引查询，回到主键索引搜索的过程成为回表

### 覆盖索引
如果一个索引已经包含需要查询的数据（主键数据，联合索引数据），则不需要回表，可以
提高查询效率，但是维护索引字段需要付出相应的代价，因此建立冗余索引来支持覆盖索引需要权衡利弊

### 最左前缀原则
InnoDB的B+树索引结构支持利用索引的“最左前缀”，来定位记录。因此在定义联合索引时
就需要考虑索引内的字段顺序

原则就索引的复用能力，例如已经存在（a，b）联合索引的情况下，就不要单独建立索引a

如果联合索引内的字段都需要单独索引，则此时需要考虑的是空间原则，为长度更小的字段
建立单独索引


### 索引下推
mysql5.6之后引入了索引下推优化，在索引遍历过程中就对索引包含的字段做判断，直接
过滤掉不满足的字段，减少回表次数
