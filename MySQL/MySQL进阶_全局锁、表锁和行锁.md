# MySQL：全局锁、表锁和行锁

## 全局锁
mysql提供了对整个数据库加锁的方法：flush tables with read lock，可以使整个数据库进入只读状态

### 使用场景
+ 全库逻辑备份，即将整个数据库中的表都读取出来生成文本

但是使用过程存在很大的风险
+ 如果备份主库，则从库无法不能执行更新等操作
+ 如果从库备份，则不能同步备份期间的主库的binlog，导致主从延迟

显然这个风险可以通过隔离界别：可重复读来解决，mysql的官方逻辑备份工具mysqldump
的single-transaction参数

但是仅仅支持事务的引擎可以使用该方法，因此ftwrl仍旧有必要，同时若执行ftwrl之后发生
异常断开数据库的连接，全局锁也会自动释放

### 表级锁
+ 开启：lock tables tablename read/write
+ 关闭：unlock tables

### 另一类表级锁：元数据锁（metadata lock）
mdl不需要显示调用，访问一个表时会自动加上。当读一个表做CRUD操作时，加上读锁；
当要对表结构进行变更操作时，加上写锁。

+ 读锁之间互不相斥，可以多个线程对一个表进行CRUD操作
+ 读写锁和写锁之间会互斥，因此不同线程之间会有先后顺序

所以当给一个表添加字段时，会加上写锁，之后所有对于该表的操作必须等到写锁释放；若添加字段的操作之前
已经有了读或写操作，就只能等待释放。如果该表该表频繁被访问，那么修改表结构的操作就会
因为大量的访问而被阻碍，同时，修改的操作也会阻碍后面大量的访问

此时可以通过在alter语句后加等待时间来解决，若一定时间没有拿到写锁，则先放弃以防阻碍后来的访问
